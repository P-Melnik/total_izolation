package pmelnik.local.sorting;

/**
 * Краткое описание алгоритма
 * СОРТИРОВКА ВЫБОРОМ
 * Принцип работы:
 * Алгоритм делит массив на две части:
 * отсортированную (в начале) и неотсортированную.
 * На каждой итерации он находит минимальный элемент
 * в неотсортированной части и меняет его местами с первым элементом
 * неотсортированной части.
 * Таким образом, отсортированная часть растет,
 * а неотсортированная — уменьшается.
 * ------------
 * Анализ сложности
 * Временная сложность (Time Complexity):
 * Худший случай: O(n²)
 * Лучший случай: O(n²)
 * Средний случай: O(n²)
 * ------------
 * Пространственная сложность (Space Complexity):
 * Во всех случаях: O(1)
 * Объяснение: Алгоритм сортирует массив на месте (in-place),
 * не используя дополнительную память,
 * пропорциональную размеру входных данных.
 * Используется только небольшое количество временных переменных.
 * ------------
 * Когда использовать?
 * Сортировка выбором подходит в основном для:
 * Образовательных целей
 * Очень маленьких массивов
 * Ситуаций, где стоимость операции обмена очень высока
 * Для реальных приложений в Java лучше использовать встроенные
 * методы Arrays.sort() (использует TimSort для объектов и QuickSort для примитивов).
 */
public class SelectionSort {

    public void sort(int[] array) {

        int n = array.length;

        // проходим все элементы массива кроме последнего
        for (int i = 0; i < n - 1; i++) {

            // предполагаем что первый элемент отсортированной части - минимальный
            int minIndex = i;

            for (int j = i + 1; j < n; j++) {

                // ищем реальный минимальный элемент в неотсортированной части
                if (array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            // меняем местами найденный минимальный элемент с первым отсортированным
            if (minIndex != i) {
                int temp = array[i];
                array[i] = array[minIndex];
                array[minIndex] = temp;
            }
        }
    }

    //todo: add optimized solution
    // 1 - check for ifSorted
    // 2 - implement bidirectional solution

}

